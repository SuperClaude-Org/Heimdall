diff --git a/vendor/opencode/packages/opencode/src/config/config.ts b/vendor/opencode/packages/opencode/src/config/config.ts
index b49912f3..7f68c1e1 100644
--- a/vendor/opencode/packages/opencode/src/config/config.ts
+++ b/vendor/opencode/packages/opencode/src/config/config.ts
@@ -257,6 +257,27 @@ export namespace Config {
   })
   export type Layout = z.infer<typeof Layout>
 
+  // Enhanced rule configuration with priority system
+  export const RuleConfig = z.union([
+    z.string(),
+    z.object({
+      path: z.string().describe("Path to rule file (absolute, relative, or glob pattern)"),
+      priority: z.number().min(0).max(100).default(50).describe("Loading priority (0-100, higher = later/override)"),
+      required: z.boolean().default(false).describe("Fail if file not found"),
+      maxSize: z.number().optional().describe("Max file size in bytes"),
+      enabled: z.boolean().default(true).describe("Enable/disable this rule")
+    })
+  ]).describe("Rule file configuration")
+  export type RuleConfig = z.infer<typeof RuleConfig>
+
+  export const RulesGlobalConfig = z.object({
+    failOnMissing: z.boolean().default(false).describe("Fail if any required rule is missing"),
+    logLevel: z.enum(["debug", "info", "warn", "error"]).default("info").describe("Logging level for rule loading"),
+    maxTotalSize: z.number().optional().describe("Max combined size of all rule files in bytes"),
+    cacheDuration: z.number().optional().describe("Cache duration in seconds")
+  }).describe("Global rules configuration")
+  export type RulesGlobalConfig = z.infer<typeof RulesGlobalConfig>
+
   export const Info = z
     .object({
       $schema: z.string().optional().describe("JSON schema reference for configuration validation"),
@@ -349,6 +370,8 @@ export namespace Config {
         )
         .optional(),
       instructions: z.array(z.string()).optional().describe("Additional instruction files or patterns to include"),
+      rules: z.array(RuleConfig).optional().describe("Custom rule files with priority and validation options. Takes precedence over default discovery."),
+      rulesConfig: RulesGlobalConfig.optional().describe("Global configuration for rule loading behavior"),
       layout: Layout.optional().describe("@deprecated Always uses stretch layout."),
       permission: z
         .object({
diff --git a/vendor/opencode/packages/opencode/src/session/system.ts b/vendor/opencode/packages/opencode/src/session/system.ts
index 15bb40c8..2a24d4ad 100644
--- a/vendor/opencode/packages/opencode/src/session/system.ts
+++ b/vendor/opencode/packages/opencode/src/session/system.ts
@@ -5,6 +5,7 @@ import { Filesystem } from "../util/filesystem"
 import { Config } from "../config/config"
 import path from "path"
 import os from "os"
+import { Log } from "../util/log"
 
 import PROMPT_ANTHROPIC from "./prompt/anthropic.txt"
 import PROMPT_ANTHROPIC_WITHOUT_TODO from "./prompt/qwen.txt"
@@ -15,6 +16,65 @@ import PROMPT_SUMMARIZE from "./prompt/summarize.txt"
 import PROMPT_TITLE from "./prompt/title.txt"
 import PROMPT_COPILOT_GPT_5 from "./prompt/copilot-gpt-5.txt"
 
+// Rule file interface for priority system
+interface RuleFile {
+  path: string
+  content: string
+  priority: number
+  size: number
+  mtime: Date
+  source: 'rules' | 'instructions' | 'default'
+  required: boolean
+}
+
+// Helper function to resolve rule paths
+async function resolveRulePath(
+  rule: string, 
+  cwd: string, 
+  root: string
+): Promise<string[]> {
+  const paths: string[] = []
+  
+  // Handle home directory
+  if (rule.startsWith("~/")) {
+    rule = path.join(os.homedir(), rule.slice(2))
+  }
+  
+  if (path.isAbsolute(rule)) {
+    if (rule.includes("*")) {
+      // Glob pattern
+      try {
+        const matches = await Array.fromAsync(
+          new Bun.Glob(path.basename(rule)).scan({
+            cwd: path.dirname(rule),
+            absolute: true,
+            onlyFiles: true,
+          })
+        )
+        paths.push(...matches)
+      } catch (err) {
+        // Invalid glob pattern, return empty
+      }
+    } else {
+      // Direct file
+      if (await Bun.file(rule).exists()) {
+        paths.push(rule)
+      }
+    }
+  } else {
+    // Relative path or pattern
+    if (rule.includes("*")) {
+      const matches = await Filesystem.globUp(rule, cwd, root).catch(() => [])
+      paths.push(...matches)
+    } else {
+      const matches = await Filesystem.findUp(rule, cwd, root)
+      paths.push(...matches)
+    }
+  }
+  
+  return paths
+}
+
 export namespace SystemPrompt {
   export function header(providerID: string) {
     if (providerID.includes("anthropic")) return [PROMPT_ANTHROPIC_SPOOF.trim()]
@@ -54,41 +114,151 @@ export namespace SystemPrompt {
     ]
   }
 
-  const LOCAL_RULE_FILES = [
-    "AGENTS.md",
-    "CLAUDE.md",
-    "CONTEXT.md", // deprecated
-  ]
-  const GLOBAL_RULE_FILES = [
-    path.join(Global.Path.config, "AGENTS.md"),
-    path.join(os.homedir(), ".claude", "CLAUDE.md"),
-  ]
-
   export async function custom() {
     const { cwd, root } = App.info().path
     const config = await Config.get()
-    const paths = new Set<string>()
-
-    for (const localRuleFile of LOCAL_RULE_FILES) {
-      const matches = await Filesystem.findUp(localRuleFile, cwd, root)
-      if (matches.length > 0) {
-        matches.forEach((path) => paths.add(path))
-        break
+    const log = Log.create({ service: "system.rules" })
+    
+    const ruleFiles: RuleFile[] = []
+    const errors: Array<{path: string, error: string, required: boolean}> = []
+    
+    // Process rules field with priority
+    if (config.rules && config.rules.length > 0) {
+      for (const ruleConfig of config.rules) {
+        const rule = typeof ruleConfig === 'string' 
+          ? { path: ruleConfig, priority: 50, required: false, enabled: true, maxSize: undefined }
+          : { ...ruleConfig, priority: ruleConfig.priority ?? 50, required: ruleConfig.required ?? false, enabled: ruleConfig.enabled ?? true }
+        
+        if (!rule.enabled) {
+          log.debug("Skipping disabled rule", { path: rule.path })
+          continue
+        }
+        
+        try {
+          const resolvedPaths = await resolveRulePath(rule.path, cwd, root)
+          
+          if (resolvedPaths.length === 0 && rule.required) {
+            const error = `Required rule file not found: ${rule.path}`
+            errors.push({ path: rule.path, error, required: true })
+            if (config.rulesConfig?.failOnMissing) {
+              throw new Error(error)
+            }
+            continue
+          }
+          
+          for (const filePath of resolvedPaths) {
+            try {
+              const file = Bun.file(filePath)
+              const stat = await file.stat().catch(() => null)
+              
+              if (!stat) {
+                errors.push({ path: filePath, error: "Failed to stat file", required: rule.required })
+                continue
+              }
+              
+              // Check size limit
+              if (rule.maxSize && stat.size > rule.maxSize) {
+                const error = `File exceeds max size: ${stat.size} > ${rule.maxSize} bytes`
+                errors.push({ path: filePath, error, required: rule.required })
+                if (rule.required && config.rulesConfig?.failOnMissing) {
+                  throw new Error(error)
+                }
+                continue
+              }
+              
+              const content = await file.text()
+              ruleFiles.push({
+                path: filePath,
+                content,
+                priority: rule.priority,
+                size: stat.size,
+                mtime: stat.mtime,
+                source: 'rules',
+                required: rule.required
+              })
+            } catch (err) {
+              const error = `Failed to read file: ${err.message}`
+              errors.push({ path: filePath, error, required: rule.required })
+              if (rule.required && config.rulesConfig?.failOnMissing) {
+                throw err
+              }
+            }
+          }
+        } catch (err) {
+          if (rule.required && config.rulesConfig?.failOnMissing) {
+            throw err
+          }
+          errors.push({ path: rule.path, error: err.message, required: rule.required })
+        }
+      }
+    } else {
+      // Fallback to default behavior if no rules specified
+      const LOCAL_RULE_FILES = ["AGENTS.md", "CLAUDE.md", "CONTEXT.md"]
+      
+      // Check local rule files
+      for (const localRuleFile of LOCAL_RULE_FILES) {
+        const matches = await Filesystem.findUp(localRuleFile, cwd, root)
+        if (matches.length > 0) {
+          for (const filePath of matches) {
+            try {
+              const file = Bun.file(filePath)
+              const stat = await file.stat()
+              const content = await file.text()
+              
+              ruleFiles.push({
+                path: filePath,
+                content,
+                priority: 50,
+                size: stat.size,
+                mtime: stat.mtime,
+                source: 'default',
+                required: false
+              })
+            } catch (err) {
+              log.warn("Failed to load default rule file", { path: filePath, error: err.message })
+            }
+          }
+          break
+        }
       }
-    }
 
-    for (const globalRuleFile of GLOBAL_RULE_FILES) {
-      if (await Bun.file(globalRuleFile).exists()) {
-        paths.add(globalRuleFile)
-        break
+      // Check global rule files (maintaining backward compatibility)
+      const globalPaths = [
+        path.join(Global.Path.config, "AGENTS.md"),
+        path.join(os.homedir(), ".claude", "CLAUDE.md"),
+      ]
+      
+      for (const globalPath of globalPaths) {
+        if (await Bun.file(globalPath).exists()) {
+          try {
+            const file = Bun.file(globalPath)
+            const stat = await file.stat()
+            const content = await file.text()
+            
+            ruleFiles.push({
+              path: globalPath,
+              content,
+              priority: 50,
+              size: stat.size,
+              mtime: stat.mtime,
+              source: 'default',
+              required: false
+            })
+            break
+          } catch (err) {
+            log.warn("Failed to load global rule file", { path: globalPath, error: err.message })
+          }
+        }
       }
     }
 
+    // Always process instructions field (in addition to rules)
     if (config.instructions) {
       for (let instruction of config.instructions) {
         if (instruction.startsWith("~/")) {
           instruction = path.join(os.homedir(), instruction.slice(2))
         }
+        
         let matches: string[] = []
         if (path.isAbsolute(instruction)) {
           if (instruction.includes("*")) {
@@ -109,17 +279,60 @@ export namespace SystemPrompt {
             matches = await Filesystem.findUp(instruction, cwd, root)
           }
         }
-        matches.forEach((path) => paths.add(path))
+        
+        for (const filePath of matches) {
+          try {
+            const file = Bun.file(filePath)
+            const stat = await file.stat()
+            const content = await file.text()
+            
+            ruleFiles.push({
+              path: filePath,
+              content,
+              priority: 60, // Instructions have slightly higher priority than defaults
+              size: stat.size,
+              mtime: stat.mtime,
+              source: 'instructions',
+              required: false
+            })
+          } catch (err) {
+            log.warn("Failed to load instruction file", { path: filePath, error: err.message })
+          }
+        }
       }
     }
-
-    const result: string[] = []
-    for (const path of paths) {
-      const content = await Bun.file(path).text()
-      result.push(content)
+    
+    // Check total size limit
+    if (config.rulesConfig?.maxTotalSize) {
+      const totalSize = ruleFiles.reduce((sum, file) => sum + file.size, 0)
+      if (totalSize > config.rulesConfig.maxTotalSize) {
+        const error = `Total rule files size (${totalSize}) exceeds limit (${config.rulesConfig.maxTotalSize})`
+        log.error(error)
+        if (config.rulesConfig?.failOnMissing) {
+          throw new Error(error)
+        }
+      }
     }
-
-    return result
+    
+    // Sort by priority (lower number = earlier loading)
+    ruleFiles.sort((a, b) => a.priority - b.priority)
+    
+    // Log summary
+    const logLevel = config.rulesConfig?.logLevel || 'info'
+    if (logLevel === 'debug' || logLevel === 'info') {
+      log.info("Loaded rule files", {
+        count: ruleFiles.length,
+        sources: {
+          rules: ruleFiles.filter(f => f.source === 'rules').length,
+          instructions: ruleFiles.filter(f => f.source === 'instructions').length,
+          default: ruleFiles.filter(f => f.source === 'default').length
+        },
+        errors: errors.length
+      })
+    }
+    
+    // Return content in priority order
+    return ruleFiles.map(file => file.content)
   }
 
   export async function get(providerID: string) {